using System;

class CoinChangeRecursive
{
    public int GetMinCoins(int[] coins, int sum)
   {
       var minCount = MinCoins(coins, coins.Length, sum);

       if (minCount == int.MaxValue) return -1;

       return (int)minCount;
   }

    private long MinCoins(int[] coins, int n, int sum)
    {
        // Базовий випадок: якщо сума дорівнює 0, то не потрібно використовувати жодної монети.
        if (sum == 0) return 0;

        // Якщо сума від'ємна або монети закінчились, то неможливо скласти суму.
        if (sum < 0 || n <= 0) return int.MaxValue;

        long withoutCoin = MinCoins(coins, n - 1, sum);
        long withCoin = MinCoins(coins, n, sum - coins[n - 1]) + 1; // use long to avoid int overflow for int.MaxValue + 1 case

        return Math.Min(withoutCoin, withCoin);
    }
}

public static void Main(string[] args)
{
    int[] coins = { 1, 2, 5 };
    int sum = 11;

    int minCoins = new CoinChangeRecursive().GetMinCoins(coins, sum);

    int minCoins = GetMinCoins(coins, sum);

    if (minCoins == -1)
        Console.WriteLine("Не можливо скласти суму " + sum + " монетами.");
    else
        Console.WriteLine("Мінімальна кількість монет для суми " + sum + " гривень: " + minCoins);
}

__Time Complexity O(cointsCount^sum); Exponential time__;
__Auxiliary Space Complexity O(sum*cointsCount)__;

https://www.enjoyalgorithms.com/blog/minimum-coin-change
